{Binexec was written by Jem Miller of Missing Link Software in 2025 for the RPMgr
package manager program. This unit was loosely based upon an example in the
Lazarus wiki at: https://wiki.freepascal.org/Executing_External_Programs.

You are welcome to modify, distribute, or use these routines as you see fit.
I do want to keep the credits displayed for those that came before you.
}
Unit binexec;

{$mode objfpc}{$H+}

Interface

Uses
    Classes,
    SysUtils,
    Process,
    Forms,
    Controls,
    Graphics,
    Dialogs,
    StdCtrls,
    Math;

Const
    BUF_SIZE = 16364; // Buffer size for reading the output in chunks

Type
    opt = Array Of Shortstring;

    { Tloginfrm }

    // This is the login form displayed to the user

    Tloginfrm = Class(TForm)
      okbtn :     TButton;
      cancelbtn : TButton;
      pwtxt :     TEdit;
      Label1 :    TLabel;
      Label2 :    TLabel;
      logtxt :    TLabel;
      Procedure FormShow(Sender : TObject);
      Procedure okbtnClick(Sender : TObject);
      Procedure cancelbtnClick(Sender : TObject);
      Procedure pwtxtKeyPress(Sender : TObject; Var Key : Char);
    private

    public

    End;

Var
    loginfrm : Tloginfrm;
    admin, // stored admin pw
   {Errstr and OutP are text output from each call to an exec process. They contain the
   entine buffer contents for the process. OutP is the stdin output text and ErrStr
   contains any and all output from stderr generated by the process. You can use these
   strings if you are not outputting to a Tmemo, they are available from all exec processes}
    ErrStr, OutP : Ansistring; //Contains all output from the process stdout
    root : Boolean = False;
    user: string;
    errnum : longint;

Function exec(Pname : String; opts : opt; outmem : Tmemo) : boolean;
Function exec(Pname : String; opts : opt) : boolean; // no output to memo. OutP has all output
Function RootExec(Pname : String; RootPw : Shortstring; outmem : Tmemo) : boolean;
Function RootExec(Pname : String; RootPw : Shortstring) : boolean; // no output to memo. OutP has all output

Implementation

Uses
    mlstr;

    {$R *.lfm}

    { Tloginfrm }
Var
    ercnt : Byte;
    ok :    Boolean;
    AProc : TProcess;
    BytesRead : Longint;
    {These are the output buffers that contain  output from each read of stdin and stderr}
    ErrBuf, Buffer : Array[1..BUF_SIZE] Of Char;
    line :  String;

Procedure Tloginfrm.cancelbtnClick(Sender : TObject);
Begin
    admin:= '';
    root:= false;
    halt(1);
End;

{If the Enter key is pressed, the OK button's click method is called}
Procedure Tloginfrm.pwtxtKeyPress(Sender : TObject; Var Key : Char);
Begin
    If key = #13 Then
    Begin
      okbtnclick(nil);
      key:= #0;
    End;

End;

{Process the OK button event. it gives the user 3 chances to login with a valid
password, and then it terminates the program.}
Procedure Tloginfrm.okbtnClick(Sender : TObject);
Begin
    admin:= pwtxt.Text;

    // see if we have root access
    ok:= rootexec('ls /root', admin);

    If not ok Then
    Begin
      Inc(ercnt);
      ShowMessage('The administrator password is incorrect. ' + I2Str(3 - ercnt) +
        ' tries remaining.');

      If ercnt > 3 Then
      Begin
        ShowMessage('Password retries exhausted.');
        halt(1);
      End;

      exit;
    End;

    root:= True;
    Close;

End;

Procedure Tloginfrm.FormShow(Sender : TObject);
Begin
    //Find out who we are
    ok:= exec('/usr/bin/whoami', ['']);
    outp:= trim(outp);
    user:= outp;

    ercnt:= 0;
    admin:= '';
    root:= false;

    If ok Then
      logtxt.Caption:= outp;

    pwtxt.SetFocus;

End;

{***** Exec Routines

READ THIS!!

OutP is an ansistring "buffer" that contains all output from stdout. It is a
global variable that is available to any unit. It will contain all output for
each call to any of the exec routines, but it is cleared on each new call.

ErrStr is also a global, but only contains output from stderr. It also gets
cleared before each new call to an exec routine.

If the result of an exec is non zero, then an error occured during the call.}

{This is a non-root process that can be executed by any user. It pipes its
output to an existing Tmemo that you pass from your program.}
Function exec(Pname : String; opts : opt; outmem : Tmemo) : boolean;
Var
    Bytes,
    cnt,
    Errcnt,
    i :   Longint;
    tmp : Ansistring;

Begin
    // Set up the process;
    AProc:= TProcess.Create(nil);
    fillchar(ErrBuf, sizeof(ErrBuf), #0);
    fillchar(Buffer, sizeof(Buffer), #0);
    OutP  := '';
    errstr:= '';
    errnum:= 0;

    Aproc.Executable:= Pname;
    i:= 0;

    //Add all of the commandline options
    While i < length(opts) Do
    Begin
      Aproc.Parameters.Add(opts[i]);
      Inc(i);
    End;

    {Process option poUsePipes has to be used so we can catch the output in real time.
    I do not use poStderrToOutPut to redirect program stdin,stdout,stderr. this way
    I can read and store errors for the program to evaluate more easily}
    Aproc.Options:= [poUsePipes];

    //Run the command)
    Aproc.Execute;

    sleep(30);
    {Needed on fast systems. you can play with this value. 10 works well for
      many modern systems, but remember that the end user may have an older,
      slower machine than you do.}

    Repeat // long repeat to ensure that we get all data

      Repeat

      Try
        bytes:= Aproc.Output.NumBytesAvailable;

        If bytes > 0 Then
        Begin
          //Read each line of output from the command process
          BytesRead:= Aproc.Output.Read(Buffer[1], min(bytes, buf_size));
          tmp:= copy(buffer, 1, bytesread);

          If pos('sudo', Buffer) = 0 Then
            line:= stripto(tmp, ':'); //strips any [sudo] output in the response

          //Append the output to the Tmemo passed to this procedure
          outmem.Append(tmp);
          OutP:= OutP + tmp;
        End;

      Finally
        errnum:= aproc.exitcode;
        application.ProcessMessages
      End;

        sleep(30);
      Until (Bytes = 0);

      //Clear the buffers so we don't keep old stuff
      fillchar(buffer, sizeof(buffer), #0);
      fillchar(errbuf, sizeof(errbuf), #0);

      Repeat
        cnt:= Aproc.Stderr.NumBytesAvailable; //Read error message

        If cnt > 0 Then
        Begin
          ErrCnt:= Aproc.Stderr.Read(ErrBuf[1], min(cnt, buf_size));
          errstr:= errstr + copy(errbuf, 1, errcnt); // add buffer contents to ErrStr

          If pos('sudo', errbuf) > 0 Then
            line:= stripto(errstr, ':');

          outmem.Append(errstr);
          application.ProcessMessages;
        End;

        sleep(30);
      Until (cnt = 0);

      //Keep reading output until the process ends and there is no more output data to read
    Until (aproc.Output.NumBytesAvailable = 0) and
          (aproc.Stderr.NumBytesAvailable = 0) and
          (aproc.Running = False);

    //After the process has finished we clean up our mess
    Errnum:= Aproc.exitcode;
    Aproc.Destroy;
    aproc:= nil;

    {If an error did occur, all output should have been written to your memo
    before getting here, so OutP will only contain a duplicate of that output.}
    Result:= Errnum = 0;

End;

{This function is the same as the above Exec function without an attached Tmemo.
output is available by reading the global ansistrings OutP and ErrStr.}
Function exec(Pname : String; opts : opt) : boolean;
Var
    Bytes,
    cnt,
    Errcnt,
    i :   Longint;
    tmp : Ansistring;

Begin
    // Set up the process;
    AProc:= TProcess.Create(nil);
    fillchar(ErrBuf, sizeof(ErrBuf), #0);
    fillchar(Buffer, sizeof(Buffer), #0);
    OutP  := '';
    errstr:= '';
    errnum:= 0;

    Aproc.Executable:= Pname;
    i:= 0;

    //Add all of the commandline options
    While i < length(opts) Do
    Begin
      Aproc.Parameters.Add(opts[i]);
      Inc(i);
    End;

    {Process option poUsePipes has to be used so we can catch the output in real time.
    I do not use poStderrToOutPut to redirect program stdin,stdout,stderr. this way
    I can read and store errors for the program to evaluate more easily}
    Aproc.Options:= [poUsePipes];

    //Run the command)
    Aproc.Execute;

    {Needed on fast systems. you can play with this value. 10 works well for
      many modern systems, but remember that the end user may have an older,
      slower machine than you do.}
    sleep(30);

    Repeat // long repeat to ensure that we get all data

      Repeat

      Try
        bytes:= Aproc.Output.NumBytesAvailable;

        If bytes > 0 Then
        Begin
          //Read each line of output from the command process
          BytesRead:= Aproc.Output.Read(Buffer[1], min(bytes, buf_size));
          OutP     := OutP + copy(buffer, 1, bytesread);

        End;

      Finally
        errnum:= aproc.exitcode;
        application.ProcessMessages
      End;

        sleep(30);
      Until (Bytes = 0);

      //Clear the buffers so we don't keep old stuff
      fillchar(buffer, sizeof(buffer), #0);
      fillchar(errbuf, sizeof(errbuf), #0);

      Repeat
        cnt:= Aproc.Stderr.NumBytesAvailable; //Read error message

        If cnt > 0 Then
        Begin
          ErrCnt:= Aproc.Stderr.Read(ErrBuf[1], min(cnt, buf_size));
          errstr:= errstr + copy(errbuf, 1, errcnt); // add buffer contents to ErrStr

          application.ProcessMessages;
        End;

        sleep(30);
      Until (cnt = 0);

      //Keep reading output until the process ends and there is no more output data to read
    Until (aproc.Output.NumBytesAvailable = 0) and (aproc.Stderr.NumBytesAvailable = 0) and
      (aproc.Running = False);

    //After the process has finished we clean up our mess
    Errnum:= Aproc.exitcode;
    Aproc.Destroy;
    aproc:= nil;

    {NOTE: It is very possible to get a process error and still have useful
    output in the OutP variable. if an exec call exits with an error code,
    check to see if OutP has data before reporting an error and aborting.}
    Result:= errnum = 0;

End;

{The RootExec functions are used for those system calls that require root access.
this version outputs to an existing Tmemo in your program in real time.}
Function RootExec(Pname : String; RootPw : Shortstring; outmem : Tmemo) : boolean;
Var
    cnt,
    Bytes,
    Errcnt,
    i :   Longint;
    tmp : Ansistring;

Begin
    // Set up the process;
    AProc:= TProcess.Create(nil);
    fillchar(ErrBuf, sizeof(ErrBuf), #0);
    fillchar(Buffer, sizeof(Buffer), #0);

    OutP  := '';
    errstr:= '';
    errnum:= 0;

    Try
      Aproc.Options:= [poUsePipes]; //Use pipes to redirect program stdin,stdout,stderr
      Aproc.Executable:= '/bin/sh'; //Run command as root using the sh shell
      i:= 0;

      aproc.Parameters.Add('-c');

    {calls the sudo program and feeds it the root password and the
    program name that you wish to run as root. Note that you do not
    need to supply full paths to programs if they are in a directory
    in the system $PATH. You must pass the entire command line with any
    switches and options, just as you would from a command prompt of
    a terminal or console.}
      Aproc.Parameters.add('echo ' + RootPw + ' | sudo -S ' + pname);

      Aproc.Execute; //Run the command. sudo will now ask for a password

      //Write the password to stdin of the sudo program:
      RootPw:= RootPw + #10;

      Aproc.Input.Write(RootPw[1], Length(RootPw)); //feed the password to the sudo program
      sleep(30);
      {Needed on fast systems. you can play with this value. 10 works well for
      many modern systems, but remember that the end user may have an older,
      slower machine than you do.}

      Bytes:= Aproc.Output.NumBytesAvailable;

      If Bytes > 0 Then
      Begin
        //There will normally be no output on passing the root password to sudo
        BytesRead:= Aproc.Output.Read(Buffer[1], min(Bytes, buf_size));
        OutP:= OutP + copy(buffer, 1, bytesread); // add buffer contents to OutP
        tmp:= copy(buffer, 1, bytesread);

        If pos('sudo', Buffer) = 0 Then
          line:= stripto(tmp, ':'); //strips any [sudo] output in the response

        //Append the output to the Tmemo passed to this function, ignoring the sudu response
        outmem.Append(tmp);
        application.ProcessMessages;
      End;

      //Clear the buffers so we don't keep old stuff
      fillchar(buffer, sizeof(buffer), #0);
      fillchar(Errbuf, sizeof(buffer), #0);

      {This gathers error output from the sudo request, such as a bad password attempt}
      Repeat
        cnt:= Aproc.Stderr.NumBytesAvailable;

        If cnt > 0 Then
        Begin
          ErrCnt:= Aproc.Stderr.Read(ErrBuf[1], min(cnt, buf_size));
          errstr:= errstr + copy(errbuf, 1, errcnt); // add buffer contents to ErrStr

          If pos('sudo', errstr) > 0 Then
            line:= stripto(errstr, ':');

          outmem.Append(errstr); // feed the string to your Tmemo
          application.ProcessMessages; // update your Tmemo
        End;

        sleep(30); // still making sure we don't outrun the response
      Until (cnt = 0);

      fillchar(RootPw, sizeof(RootPw), #0); //wipe the password
      RootPw:= 'hohoho'; //just a bit more confusion for hackers snooping
    Finally
      errnum:= Aproc.ExitCode;
    End;

    Repeat // we must ensure that we get all output and errors. this repeat does that

    Try
      Repeat

        Bytes:= Aproc.output.NumBytesAvailable;

        If Bytes > 0 Then
        Begin
          //Read each line of output from the command process
          BytesRead:= Aproc.output.Read(Buffer[1], min(Bytes, buf_size));
          tmp := copy(buffer, 1, bytesread); // use a temporary string
          OutP:= OutP + tmp; // add buffer contents to OutP

          If pos('sudo', Buffer) = 0 Then
            line:= stripto(tmp, ':'); //stripto is part of my mlstr unit

          //Append the output to the Tmemo passed to this procedure, ignoring the sudu response
          outmem.Append(tmp);
          application.ProcessMessages; // update the Tmemo
        End;

        sleep(30); // slumber party
      Until (bytes = 0);

      //Clear the buffers so we don't keep old stuff
      fillchar(buffer, sizeof(buffer), #0);
      fillchar(Errbuf, sizeof(buffer), #0);

      Repeat
        cnt:= Aproc.Stderr.NumBytesAvailable;

        If cnt > 0 Then
        Begin
          ErrCnt:= Aproc.Stderr.Read(ErrBuf[1], min(cnt, buf_size));
          errstr:= errstr + copy(errbuf, 1, errcnt); // add buffer contents to ErrStr

          If pos('sudo', errbuf) > 0 Then
            line:= stripto(errstr, ':');

          outmem.Append(errstr);
          application.ProcessMessages;
        End;

        sleep(30); //sleepy time
      Until (cnt = 0);

    Finally
      errnum:= aproc.exitcode;
      application.ProcessMessages;
    End;

  {Keep reading output until the process ends and there is no more output or
  error data to read}
    Until (Bytes = 0) and
          (cnt = 0) and
          (aproc.Running = False);

    application.ProcessMessages;

    //After the process has finished we clean up our mess
    Errnum:= Aproc.exitcode;
    Aproc.Destroy;
    aproc:= nil;

    {If an error did occur, all output should have been written to your memo
    before getting here, so OutP will only contain a duplicate of that output.}
    Result:= Errnum = 0;

End;

{This version of RootExec does not output to a Tmemo, but is otherwise the same
as the function above. Output can be read from OutP and ErrStr.}
Function RootExec(Pname : String; RootPw : Shortstring) : boolean;
Var
    bytes,
    Errcnt,
    cnt,
    i :   Longint;
    tmp : Ansistring;

Begin
    // Set up the process;
    AProc:= TProcess.Create(nil);
    fillchar(ErrBuf, sizeof(ErrBuf), #0);
    fillchar(Buffer, sizeof(Buffer), #0);

    OutP  := '';
    errstr:= '';
    errnum:= 0;

    Try
      Aproc.Options:= [poUsePipes]; //Use pipes to redirect program stdin,stdout,stderr
      Aproc.Executable:= '/bin/sh'; //Run command as root using the sh shell
      i:= 0;

      aproc.Parameters.Add('-c');

    {calls the sudo program and feeds it the root password and the
    program name that you wish to run as root. Note that you do not
    need to supply full paths to programs if they are in a directory
    in the system $PATH. You must pass the entire command line with any
    switches and options, just as you would from a command prompt of
    a terminal or console.}
      Aproc.Parameters.add('echo ' + RootPw + ' | sudo -S ' + pname);

      Aproc.Execute; //Run the command. sudo will now ask for a password

      //Write the password to stdin of the sudo program:
      RootPw:= RootPw + #10;

      Aproc.Input.Write(RootPw[1], Length(RootPw)); //feed the password to the sudo program
      sleep(30);
      {Needed on fast systems. you can play with this value. 10 works well for
      many modern systems, but remember that the end user may have an older,
      slower machine than you do.}

      Bytes:= Aproc.Output.NumBytesAvailable;

      If Bytes > 0 Then
      Begin
        //There will normally be no output on passing the root password to sudo
        BytesRead:= Aproc.Output.Read(Buffer[1], min(Bytes, buf_size));
        OutP     := OutP + copy(buffer, 1, bytesread); // add buffer contents to OutP

        application.ProcessMessages;
      End;

      //Clear the buffers so we don't keep old stuff
      fillchar(buffer, sizeof(buffer), #0);
      fillchar(Errbuf, sizeof(buffer), #0);

      {This gathers error output from the sudo request, such as a bad password attempt}
      Repeat
        cnt:= Aproc.Stderr.NumBytesAvailable; //Read error message

        If cnt > 0 Then
        Begin
          ErrCnt:= Aproc.Stderr.Read(ErrBuf[1], min(cnt, buf_size));
          errstr:= errstr + copy(errbuf, 1, errcnt); // add buffer contents to ErrStr

          application.ProcessMessages; // update your Tmemo
        End;

        sleep(30); // still making sure we don't outrun the response
      Until (cnt = 0);

      fillchar(RootPw, sizeof(RootPw), #0); //wipe the password
      RootPw:= 'hohoho'; //just a bit more confusion for hackers snooping
    Finally
      errnum:= Aproc.ExitCode;
    End;

    Repeat // we must ensure that we get all output and errors. this repeat does that

    Try
      Repeat

        Bytes:= Aproc.output.NumBytesAvailable;

        If Bytes > 0 Then
        Begin
          //Read each line of output from the command process
          BytesRead:= Aproc.output.Read(Buffer[1], min(Bytes, buf_size));
          OutP     := OutP + copy(buffer, 1, bytesread); // add buffer contents to OutP

          application.ProcessMessages;
        End;

        sleep(30); // slumber party
      Until (bytes = 0);

      //Clear the buffers so we don't keep old stuff
      fillchar(buffer, sizeof(buffer), #0);
      fillchar(Errbuf, sizeof(buffer), #0);

      Repeat
        cnt:= Aproc.Stderr.NumBytesAvailable; //Read error message

        If cnt > 0 Then
        Begin
          ErrCnt:= Aproc.Stderr.Read(ErrBuf[1], min(cnt, buf_size));
          errstr:= errstr + copy(errbuf, 1, errcnt); // add buffer contents to ErrStr

          application.ProcessMessages;
        End;

        sleep(30);
      Until (cnt = 0);

    Finally
      errnum:= aproc.exitcode;
      application.ProcessMessages;
    End;

  {Keep reading output until the process ends and there is no more output or
  error data to read}
    Until (Bytes = 0) and
          (cnt = 0) and
          (aproc.Running = False);

    application.ProcessMessages;

    //After the process has finished we clean up our mess
    Errnum:= Aproc.exitcode;
    Aproc.Destroy;
    aproc:= nil;

    {NOTE: It is very possible to get a process error and still have useful
    output in the OutP variable. if an exec call exits with an error code,
    check to see if OutP has data before reporting an error and aborting.}
    Result:= Errnum = 0;

End;

End.
